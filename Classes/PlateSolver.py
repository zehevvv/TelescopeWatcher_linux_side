import subprocess
import os
import re
import cv2
import numpy as np
import requests
import time

class PlateSolver:
    def __init__(self):
        # Use xvfb-run to simulate display for ASTAP
        self.astap_command = ["xvfb-run", "-a", "astap"] 
        self.temp_image_path = "/tmp/solve_image.jpg"
        self.report_path = "/tmp/astap_report.ini"
    
    def solve(self, camera_device, timeout=30):
        """
        Captures an image, solves it using ASTAP, and returns RA/DEC.
        """
        # 1. Capture Image
        print(f"Capturing image for plate solving from {camera_device.camera_model}...")
        img = self._capture_frame(camera_device)
        
        if img is None:
            return {"success": False, "error": "Failed to capture image"}

        img = self._prepare_image_for_astap(img)

        # 2. Save Image for ASTAP
        cv2.imwrite(self.temp_image_path, img)
        if os.path.exists(self.report_path):
            os.remove(self.report_path)
        
        try:
            attempt_variants = [
                {"label": "blind", "args": []},
                {"label": "fov_2", "args": ["-fov", "2"]},
                {"label": "fov_5", "args": ["-fov", "5"]},
                {"label": "fov_10", "args": ["-fov", "10"]},
            ]
            per_attempt_timeout = max(5, int(timeout / len(attempt_variants)))
            last_stdout = ""
            last_stderr = ""
            last_return_code = -1

            for attempt in attempt_variants:
                cmd = self.astap_command + [
                    "-f", self.temp_image_path,
                    "-r", self.report_path,
                    "-z", "0"
                ] + attempt["args"]

                print(f"Running ASTAP attempt '{attempt['label']}': {' '.join(cmd)}")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=per_attempt_timeout)
                last_stdout = (result.stdout or "").strip()
                last_stderr = (result.stderr or "").strip()
                last_return_code = result.returncode

                if os.path.exists(self.report_path):
                    parsed = self._parse_results(self.report_path)
                    if parsed.get("success"):
                        parsed["solve_attempt"] = attempt["label"]
                        return parsed

            if "No solution found" in last_stdout:
                return {
                    "success": False,
                    "error": "No plate-solve solution found. Try longer exposure, better focus, or a richer star field.",
                    "astap_stdout": last_stdout[-1200:],
                    "astap_stderr": last_stderr[-1200:]
                }

            return {
                "success": False,
                "error": f"Solving failed (return code {last_return_code}, no report generated)",
                "astap_stdout": last_stdout[-1200:],
                "astap_stderr": last_stderr[-1200:]
            }

        except subprocess.TimeoutExpired:
            return {"success": False, "error": "ASTAP timed out"}
        except Exception as e:
            return {"success": False, "error": f"Error running ASTAP: {str(e)}"}

    def _parse_results(self, report_path):
        """Parses the .ini file generated by ASTAP"""
        try:
            with open(report_path, 'r') as f:
                content = f.read()
            
            # ASTAP .ini output format usually looks like:
            # PLTSOLVD=T
            # CRVAL1=123.456 (RA in degrees)
            # CRVAL2=45.678 (DEC in degrees)
            
            if "PLTSOLVD=T" in content:
                # Extract RA/DEC using regex
                ra_match = re.search(r'CRVAL1=([\d\.\-]+)', content)
                dec_match = re.search(r'CRVAL2=([\d\.\-]+)', content)
                rotation_match = re.search(r'CROTA2=([\d\.\-]+)', content)
                
                ra = float(ra_match.group(1)) if ra_match else 0
                dec = float(dec_match.group(1)) if dec_match else 0
                rotation = float(rotation_match.group(1)) if rotation_match else 0
                
                return {
                    "success": True,
                    "ra_deg": ra,
                    "dec_deg": dec,
                    "rotation": rotation,
                    "ra_hours": ra / 15.0  # Convert degrees to hours
                }
            else:
                return {"success": False, "error": "Could not solve image"}
                
        except Exception as e:
            return {"success": False, "error": f"Error parsing results: {str(e)}"}

    def _capture_frame(self, camera_device):
        """
        Reused logic from CameraRotationFinder to get a single frame
        """
        # Ensure we know the device
        if not camera_device.video_device:
            camera_device.video_device = camera_device.get_camera_device_by_type()
            
        if camera_device.camera_type == "MJPG":
            url = f"http://localhost:{camera_device.video_port}/?action=snapshot"
            try:
                response = requests.get(url, timeout=2)
                if response.status_code == 200:
                    image_array = np.asarray(bytearray(response.content), dtype=np.uint8)
                    frame = cv2.imdecode(image_array, cv2.IMREAD_GRAYSCALE) # ASTAP works well with BW
                    if frame is not None:
                        return cv2.rotate(frame, cv2.ROTATE_180) # Keep your existing rotation logic
            except Exception as e:
                print(f"Snapshot failed: {e}")

        elif camera_device.camera_type == "H264":
            rtsp_url = f"rtsp://localhost:{camera_device.rtsp_port}/cam"
            cap = None
            try:
                cap = cv2.VideoCapture(rtsp_url)
                if cap.isOpened():
                    ret, frame_read = cap.read()
                    if ret and frame_read is not None:
                        gray = cv2.cvtColor(frame_read, cv2.COLOR_BGR2GRAY)
                        return cv2.rotate(gray, cv2.ROTATE_180)
            except Exception as e:
                print(f"RTSP capture failed: {e}")
            finally:
                if cap:
                    cap.release()

        if camera_device.video_device:
            cap = None
            try:
                cap = cv2.VideoCapture(camera_device.video_device)
                if cap.isOpened():
                    for _ in range(5):
                        cap.read()
                    ret, frame_read = cap.read()
                    if ret and frame_read is not None:
                        gray = cv2.cvtColor(frame_read, cv2.COLOR_BGR2GRAY)
                        return cv2.rotate(gray, cv2.ROTATE_180)
            except Exception as e:
                print(f"Direct capture failed: {e}")
            finally:
                if cap:
                    cap.release()
        
        # Add H264/RTSP snapshot logic here if needed (e.g., using ffmpeg to grab one frame)
        return None

    def _prepare_image_for_astap(self, frame):
        if frame is None:
            return None

        if len(frame.shape) == 3:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        min_dim = 1024
        h, w = frame.shape[:2]
        scale = max(min_dim / max(w, 1), min_dim / max(h, 1), 1.0)
        if scale > 1.0:
            new_w = int(w * scale)
            new_h = int(h * scale)
            frame = cv2.resize(frame, (new_w, new_h), interpolation=cv2.INTER_CUBIC)

        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        frame = clahe.apply(frame)
        return frame